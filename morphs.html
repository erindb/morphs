<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Morphs</title>
<meta name="viewport" content="initial-scale=1.0">
</head> 

<body>

<svg id="polygon"></svg>

<!-- Scripts -->
<script src="./raphael.js" type="text/javascript"></script>

<script>

function shuffle(v) { newarray = v.slice(0);for(var j, x, i = newarray.length; i; j = parseInt(Math.random() * i), x = newarray[--i], newarray[i] = newarray[j], newarray[j] = x);return newarray;} // non-destructive.

function uniformAroundMean(mean, radius) {
  var radius = radius || 0.2;
  if (mean + radius < 1) {
    var upper = mean + radius;
  } else {
    var upper = 1;
  }
  if (mean - radius > .1) {
    var lower = mean - radius;
  } else {
    var lower = .1;
  }
  var interval = upper - lower;
  return Math.random() * interval + lower;
}

function ColorRandomizer(nSteps) {
  var nSteps = nSteps || 10;
  function hues(n) {
    var h = [];
    var offset = Math.random() * .99 / n;
    for (var i=0;i<n-1;i++) {
      h.push((i/n)+offset);
    }
    return shuffle(h);
  }
  var myHues = hues(nSteps);
  this.get = get;
  function get(something, saturation, value) {
    if (myHues.length < 1) {
      myHues = hues(nSteps);
    }
    var h = myHues.shift();
    var s = uniformAroundMean(.99, .1);
    var v = uniformAroundMean(.99, .1);
    return Raphael.hsb2rgb(h, s, v).hex;
  }
}

var colorScheme = new ColorRandomizer;
  
function uniform(a, b) {
  return ( (Math.random()*(b-a))+a );
}

function bernoulli() {
  if (Math.random() > 0.5) {return true;} else {return false;}
}

function attrify(p) {
  return {path: p.attr().path.toString(),
          fill:p.attr().fill,
          "stroke-width":p.attr()["stroke-width"]}
}

function sign(x) {
  if (x < 0) { return -1; } else {return 1}
}

function dist(now, old) {
  return Math.sqrt( Math.pow(now.x - old.x, 2) + Math.pow(now.y - old.y, 2) );
}

function curveTo(old, now) {
  var d = dist(now, old);
  if (d < 10) { return " L " + now.x + "," + now.y; } else {
    var mx = (now.x + old.x)/2;
    var my = (now.y + old.y)/2;
    var median = {x: mx, y: my};
    var D = dist(center, median);
    var rx_ub = center.x - Math.abs(median.x - center.x);
    var ry_ub = center.y - Math.abs(median.y - center.y);
    var rx = uniform(0,rx_ub);
    var ry = uniform(0,ry_ub);
    var qx = mx + (rx*(mx - center.x)/D);
    var qy = my + (ry*(my - center.y)/D);
    return " Q " + qx + "," + qy + " " + now.x + "," + now.y;
  }
}

var size = {x: 300, y: 300};
var center = {x: size.x/2, y: size.y/2};

/*\
polygon
[ method ]
- n (integer) number of vertices for the polygon
\*/
function polygon(n) {
  var max_radius = Math.min(center.x, center.y);
  var vertices = [];
  for (var i=0; i<n; i++) {
    //polar coordinates of vertices such that if you divide a circle into n
    //evenly spaced sectors, each sector will have exactly one vertex whose
    //angle from the origin falls in that sector, and the radius is a positive
    //number between 50 and 300.
    var theta_lb = i*2*Math.PI/n; //lower bound
    var theta_ub = (i+1)*2*Math.PI/n; //upper bound
    var theta = uniform( theta_lb, theta_ub ); //in radians
    var radius = uniform( max_radius*0.1, max_radius );
    //convert to rectangular coordinates
    var x = center.x + radius*Math.cos(theta);
    var y = center.y + radius*Math.sin(theta);
    vertices.push({x:x, y:y})
  }
  var path = "M " + vertices[0].x + "," + vertices[0].y;
  for (var i=1; i<n; i++) {
    var curve = bernoulli();
    var x = vertices[i].x;
    var y = vertices[i].y;
    if (curve) {
      var old = {x: vertices[i-1].x, y: vertices[i-1].y};
      var now = {x: x, y:y};
      var add = curveTo(old, now);
      path += add;
    } else {
      path += " L " + x + "," + y;
    }
  }
  var curve = bernoulli();
  if (curve) {
    var now = {x: vertices[0].x, y: vertices[0].y};
    var old = {x: vertices[n-1].x, y: vertices[n-1].y};
    path += curveTo(old, now);
  } else {
    path += " L " + x + "," + y;
  }
  path += " Z";
  return path;
  /*
  for (var i=0; i<n; i++) {
    var c = colors[i];
    //polar coordinates of vertices such that if you divide a circle into n
    //evenly spaced sectors, each sector will have exactly one vertex whose
    //angle from the origin falls in that sector, and the radius is a positive
    //number between 50 and 300.
    var theta_lb = i*2*Math.PI/n; //lower bound
    var theta_ub = (i+1)*2*Math.PI/n; //upper bound
    var theta = uniform( theta_lb, theta_ub ); //in radians
    var radius = uniform( max_radius/10, max_radius );
    //convert to rectangular coordinates
    var x = center.x + radius*Math.cos(theta);
    var y = center.y + radius*Math.sin(theta);
    if (i > 0) {
      if (y > max_radius*0.7) {var ry = 200} else {var ry = uniform(50, 200);}
      if (x > max_radius*0.7) {var rx = 200} else {var rx = uniform(50, 200);}
      path +=" A "+rx+","+ry+" 0 0 1";
    }
    path += ( " " + x.toString() + "," + y.toString() );
  }
  path += " Z";
  return path;
  */
}

var paper = Raphael("polygon", size.x, size.y);
var n = 6; //number of vertices for the shapes
var color = colorScheme.get()
var poly1 = paper.path(polygon(n));
var poly2 = paper.path(polygon(n));
poly2.hide();
poly1.attr({"stroke-width":4, "fill":color});
poly2.attr({"stroke-width":4, "fill":color});
poly1.animate(attrify(poly2), 1000);
var origin = paper.circle(center.x, center.y, 3);
origin.attr({fill:"black"});
</script>

</body>
