<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Morphs</title>
<meta name="viewport" content="initial-scale=1.0">
</head> 

<body>

<svg id="polygon"></svg>

<!-- Scripts -->
<script src="./raphael.js" type="text/javascript"></script>

<script>

function shuffle(v) { newarray = v.slice(0);for(var j, x, i = newarray.length; i; j = parseInt(Math.random() * i), x = newarray[--i], newarray[i] = newarray[j], newarray[j] = x);return newarray;} // non-destructive.

function uniformAroundMean(mean, radius) {
  var radius = radius || 0.2;
  if (mean + radius < 1) {
    var upper = mean + radius;
  } else {
    var upper = 1;
  }
  if (mean - radius > .1) {
    var lower = mean - radius;
  } else {
    var lower = .1;
  }
  var interval = upper - lower;
  return Math.random() * interval + lower;
}

function ColorRandomizer(nSteps) {
  var nSteps = nSteps || 10;
  function hues(n) {
    var h = [];
    var offset = Math.random() * .99 / n;
    for (var i=0;i<n-1;i++) {
      h.push((i/n)+offset);
    }
    return shuffle(h);
  }
  var myHues = hues(nSteps);
  this.get = get;
  function get(something, saturation, value) {
    if (myHues.length < 1) {
      myHues = hues(nSteps);
    }
    var h = myHues.shift();
    var s = uniformAroundMean(.99, .1);
    var v = uniformAroundMean(.99, .1);
    return Raphael.hsb2rgb(h, s, v).hex;
  }
}

var colorScheme = new ColorRandomizer;
  
function uniform(a, b) {
  return ( (Math.random()*(b-a))+a );
}

function attrify(p) {
  return {path: p.attr().path.toString(),
          fill:p.attr().fill,
          "stroke-width":p.attr()["stroke-width"]}
}

var size = {x: 300, y: 300};
var center = {x: size.x/2, y: size.y/2};

/*\
polygon
[ method ]
- n (integer) number of vertices for the polygon
\*/
function polygon(n) {
  var path = "M";
  var colors = ["red", "yellow", "green", "blue"];
  var max_radius = Math.min(center.x, center.y);
  for (var i=0; i<n; i++) {
    var c = colors[i];
    //polar coordinates of vertices such that if you divide a circle into n
    //evenly spaced sectors, each sector will have exactly one vertex whose
    //angle from the origin falls in that sector, and the radius is a positive
    //number between 50 and 300.
    var theta_lb = i*2*Math.PI/n; //lower bound
    var theta_ub = (i+1)*2*Math.PI/n; //upper bound
    var theta = uniform( theta_lb, theta_ub ); //in radians
    var radius = uniform( max_radius/10, max_radius );
    //convert to rectangular coordinates
    var x = center.x + radius*Math.cos(theta);
    var y = center.y + radius*Math.sin(theta);
    path += ( " " + x.toString() + "," + y.toString() );
  }
  path += " Z";
  return path;
}

var paper = Raphael("polygon", size.x, size.y);
var n = 9; //number of vertices for the shapes
var color = colorScheme.get()
var poly1 = paper.path(polygon(n));
var poly2 = paper.path(polygon(n));
poly2.hide();
poly1.attr({"stroke-width":4, "fill":color});
poly2.attr({"stroke-width":4, "fill":color});
poly1.animate(attrify(poly2), 1000);
</script>

</body>
