<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Morphs</title>
<meta name="viewport" content="initial-scale=1.0">
</head> 

<body>

<svg id="polygon"></svg>

<!-- Scripts -->
<script src="./raphael.js" type="text/javascript"></script>

<script>

function shuffle(v) { newarray = v.slice(0);for(var j, x, i = newarray.length; i; j = parseInt(Math.random() * i), x = newarray[--i], newarray[i] = newarray[j], newarray[j] = x);return newarray;} // non-destructive.

function uniformAroundMean(mean, radius) {
  var radius = radius || 0.2;
  if (mean + radius < 1) {
    var upper = mean + radius;
  } else {
    var upper = 1;
  }
  if (mean - radius > .1) {
    var lower = mean - radius;
  } else {
    var lower = .1;
  }
  var interval = upper - lower;
  return Math.random() * interval + lower;
}

function ColorRandomizer(nSteps) {
  var nSteps = nSteps || 10;
  function hues(n) {
    var h = [];
    var offset = Math.random() * .99 / n;
    for (var i=0;i<n-1;i++) {
      h.push((i/n)+offset);
    }
    return shuffle(h);
  }
  var myHues = hues(nSteps);
  this.get = get;
  function get(something, saturation, value) {
    if (myHues.length < 1) {
      myHues = hues(nSteps);
    }
    var h = myHues.shift();
    var s = uniformAroundMean(.99, .1);
    var v = uniformAroundMean(.99, .1);
    return Raphael.hsb2rgb(h, s, v).hex;
  }
}

var colorScheme = new ColorRandomizer;
  
function uniform(a, b) {
  return ( (Math.random()*(b-a))+a );
}

function bernoulli() {
  if (Math.random() > 0.5) {return true;} else {return false;}
}

function attrify(p) {
  return {path: p.attr().path.toString(),
          fill:p.attr().fill,
          "stroke-width":p.attr()["stroke-width"]}
}

function sign(x) {
  if (x < 0) { return -1; } else {return 1}
}

function dist(now, old) {
  return Math.sqrt( Math.pow(now.x - old.x, 2) + Math.pow(now.y - old.y, 2) );
}

function curveTo(polar_old, polar_now) {
  //takes in polar coordinates!!!!
  var now = rect(polar_now);
  var old = rect(polar_old);
  var d = dist(now, old);
  if (d < 10) { return " L " + polar_now.x + "," + polar_now.y; } else {
    var q = { theta: (polar_now.theta + polar_old.theta)/2,
              r: uniform(Math.min(polar_now.r, polar_old.r), max_radius*2) };
    return " Q " + rect(q).x + "," + rect(q).y + " " + now.x + "," + now.y;
  }
}

var size = {x: 300, y: 300};
var center = {x: size.x/2, y: size.y/2};
var max_radius = Math.min(center.x, center.y);

function rect(p) {
  //convert to rectangular coordinates
  var x = center.x + p.r*Math.cos(p.theta);
  var y = center.y + p.r*Math.sin(p.theta);
  return {x: x, y: y};
}

/*\
polygon
[ method ]
- n (integer) number of vertices for the polygon
\*/
function polygon(n) {
  var vertices = [];
  for (var i=0; i<n; i++) {
    //polar coordinates of vertices such that if you divide a circle into n
    //evenly spaced sectors, each sector will have exactly one vertex whose
    //angle from the origin falls in that sector, and the radius is a positive
    //number between 50 and 300.
    var theta_lb = i*2*Math.PI/n; //lower bound
    var theta_ub = (i+1)*2*Math.PI/n; //upper bound
    var theta = uniform( theta_lb, theta_ub ); //in radians
    var radius = uniform( max_radius*0.1, max_radius*0.5 );
    /*
    */
    vertices.push({theta:theta, r:radius})
  }
  var first = rect(vertices[0]);
  var path = "M " + first.x + "," + first.y;
  for (var i=1; i<n; i++) {
    var curve = bernoulli();
    var now = rect(vertices[i]);
    if (curve) {
      path += curveTo(vertices[i-1], vertices[i]); //takes polar coords!!!
    } else {
      path += " L " + now.x + "," + now.y;
    }
  }
  var curve = bernoulli();
  if (curve) {
    var now = {x: vertices[0].x, y: vertices[0].y};
    var old = {x: vertices[n-1].x, y: vertices[n-1].y};
    path += curveTo(old, now);
  } else {
    path += " L " + now.x + "," + now.y;
  }
  path += " Z";
  console.log(path);
  return path;
}

var paper = Raphael("polygon", size.x, size.y);
var n = 10; //number of vertices for the shapes
var color = colorScheme.get()
var poly1 = paper.path(polygon(n));
var poly2 = paper.path(polygon(n));
poly2.hide();
poly1.attr({"stroke-width":4, "fill":color});
poly2.attr({"stroke-width":4, "fill":color});
poly1.animate(attrify(poly2), 1000);
//var origin = paper.circle(center.x, center.y, 3);
//origin.attr({fill:"black"});
</script>

</body>
